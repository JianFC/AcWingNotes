### L3C2 Lesson1

#### Splay

> * Splay是平衡树的一种（Splay，红黑树，treap（很多操作做不了），SBT（size balance tree），AVL，B树，B+树），B树和B+树是多叉树，硬盘里用得比较多。
>
> * Splay代码适中，非常灵活，支持很多操作，例如可以处理有关线段的问题（例如子序列翻转，此时线段树无法处理，且比线段树更加灵活）
>
>   Splay基本知识：
>
> 1. 平衡二叉树，期望高度是O(logn)级别
>
> 2. 有左旋和右旋操作，需要维护父亲结点。**左右旋在保证中序遍历结果不变的情况下，能够调整树的高度。**
>
>    ![](img1//1.png)
>
> 3. 如何保证树的平均高度是O(logn)级别
>
>    每一次插入，查询后即将当前点旋转至树根，同时保证中序遍历不变
>
>    **核心思想：**每操作一个结点，均将改结点旋转至树根。某一个点如果当前用到，那么这个点之后可能还会被用到（局部性原理，缓存）
>
>    **结论**：不管在什么样的数据，每次操作时间复杂度平均是O(logN)，证明暂时忽略。
>
> 4. 如何将某个点旋转至树根（Splay操作，代码中定义为**Splay函数**）
>
>    Splay(x, k) 将x点旋转至k点下面，旋转至左下还是右下取决于x与k的大小关系
>
>    Splay(x, 0) 则表示将点x旋转到根
>
>    步骤：两大类，四种小情况
>
>    ![](img1//2.png)
>
>    1. 第一种情况，先转y，再转x。（直线）
>
>       ![](img1//3.png)
>
>    2. 第二种情况，先转x，再转x。（折线）
>
>       ![](img1//4.png)
>
>    3. 另外两种情况对称实现
>
>    4. k一般而言只有两种情况，k=0（x转到根节点位置）或者k=根节点（x转到根节点下面）
>
> 5.  操作举例：
>
>    1. 插入
>
>       1. 插入一个数：根据BST规则找到x应该放的位置，再将x splay操作到根节点位置
>
>       2. 将一个序列插入至y的后面（保证插完后中序遍历序列在y之后）
>
>          ![](img1//5.png)
>
>          1. 找到y的后继z（大于y的最小值）
>
>             ![](img1//6.png)
>
>          2. 将y转到根，splay(y, 0)
>
>          3. 将z转到y的下面，splay(z, y)，旋转完后此时z的左子树为空。将序列插入到(y, z)之间，即将序列构造成BST后插入为z的左子树上。
>
>             ![](img1//7.png)
>
>    2. 删除一段序列[L, R]
>
>       1. 找到L的前驱L-1, R的后继R+1
>
>       2. 将L-1转到根节点，R+1转到根节点下。此时R的左子树即为[L, R]这一段序列。然后将左儿子置为空，即删除序列[L, R]
>
>          ![](img1//8.png)
>
>    3. 找前驱/后继，找第k个点... 和普通平衡树一样
>
> 6. Splay如何维护信息
>
>    1. 找第k个数（需要维护size和cnt，类似treap）。**pushup()** 负责需要维护信息。pushup() 放置在**旋转函数最后**（类似treap）
>
>    2. 懒标记，flag（类似线段树）。**pushdown()** 将懒标记下传。pushdown() 函数放置在**递归操作之前**
>
>       翻转序列操作：
>
>       ![](img1//9.png)
>
>    3. 其他信息....
>
>    4. Splay开始时能满足BST性质，之后左右旋转插入后可能不能满足BST定义：左子树<父结点，右子树>父结点，但Splay一定保证**中序遍历结果是当前序列的顺序**，**splay的中序遍历结果是我们最终的需要维护的序列**，但不一定保证像BST那样有序。只有插入时有序，其他情况下不一定有序。
>
>    5. 同treap一样，会加入两个哨兵
>
> 
>
> Splay模板题
>
> 
>
> 
>
> 
>
>  
>
> 
>
> 
>
> 
>
> 
>
> 
>
> 

