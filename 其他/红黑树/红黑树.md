### 红黑树



> 讲义
>
> ![](img//1.png)
>
> ![](img//2.png)
>
> 
>
> 竞赛常用：splay，treap，fhqtreap
>
> 
>
> **红黑树**
>
> ![](img//3.png)
>
> 性质（理解补充）：
>
> * 最短路径，最长路径。期望高度O(logN)，红黑树所有操作都是O(logN)级别
>
>   ![](img//4.png)
>
> 操作：
>
> * 插入
>
>   ![](img//5.png)
>
>   1. 先按照BST的规则插入
>
>      ![](img//6.png)
>
>      1. 左右旋
>
>         ![](img//7.png)
>
>   2. 维护红黑树的性质
>
>      1. 如果插入结点是根节点，直接把该节点变为黑色
>
>      2. 如果插入的结点的父结点是黑色，则当前结点变为红色，其他不做操作
>
>      3. 如果插入的结点父结点是红色
>
>         1. 情况1（需进一步递归操作）
>
>            ![](img//8.png)
>         
>         2. 情况2 （转化为情况3）
>         
>            ![](img//9.png)
>         
>         3. 情况3（最终满足红黑性质）
>         
>            ![](img//10.png)
>         
>            ![](img//11.png)
>         
>         4. 情况汇总
>         
>            ![](img//12.png)
>         
>            
>
> * 删除
>
>   1.  按照BST规则先删除结点
>
>      1.   情况1
>
>         ![](img//13.png)
>
>      2. 情况2
>
>         ![](img//14.png)
>
>      3. 情况3
>
>         ![](img//15.png)
>
>   2. 维护红黑树的性质
>
>      如果删除的点是红色点，则没有影响，无需操作
>
>      删除的点a是**黑色**点，则给替代a位置点b的颜色多赋值一个**黑色**(留下a点的颜色)，即b点的颜色是“红+黑”或者“黑+黑”。
>
>      * 如果删除的点a至少有一个左右儿子，则最终一定会转换成以下情况
>
>      ![](img//16.png)
>
>      * 如果删除的点a没有左右儿子，由于红黑树多维护了Nil空结点c，且空结点为黑色，所以将a的黑色累加到空结点c（黑+黑）上。
>
>        ![](img//17.png)
>
>      将替代删除的a点位置的点设为x点
>
>      1. 如果x = 红+黑，则将x = 黑
>
>      2. 如果x是根节点，则x = 黑+黑，且root结点去掉一个黑色仍满足性质5，故将x = 黑，即所有路径都去掉一个黑色点
>
>         ![](img//18.png)
>
>      3. 如果不是以上情况（当前结点”黑+黑“，且不是根节点）
>
>         1. 情况1（将兄弟结点变为黑色->情况2，3，4，最多执行O(logN)次）
>
>            ![](img//19.png)
>
>         2. 情况2（将要处理的结点往上移一层->不断递归至根节点解决，2最多执行O(logN)次，同时顺带可能执行让1执行O(logN)次）
>
>            ![](img//20.png)
>
>         3. 情况3 （将兄弟结点右儿子变为红色->情况4，最多执行1次）
>
>            ![](img//21.png)
>
>         4. 情况4（直接解决，最多执行一次）
>
>            ![](img//22.png)
>
>         因此整个操作的时间复杂度是O(logN)级别
>
>         ![](img//23.png)
>
>         
>
> * 修改（先删除，后插入）
>
>   











